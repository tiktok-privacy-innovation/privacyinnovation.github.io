name: Sync README Sections from Multiple Repositories

on:
  push:
    branches:
      - main
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * *'

jobs:
  sync-readmes:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Target Repository
      uses: actions/checkout@v3

    - name: Clone Source Repositories
      run: |
        git clone https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/tiktok-privacy-innovation/PETAce.git petace-repo

    - name: Extract and Sync README Sections
      id: sync
      run: |
        sources=(
          "petace-repo/README.md # PETAce"
          "petace-repo/README.md ## Requirements"
        )
        targets=(
          "content/en/docs/petace/Overview/_index.md"
          "content/en/docs/petace/Getting started/_index.md"
        )
        start_markers=(
          "<!-- start-petace-overview -->"
          "<!-- start-petace-requirements -->"
        )
        end_markers=(
          "<!-- end-petace-overview -->"
          "<!-- end-petace-requirements -->"
        )

        extract_section() {
            local source_file=$1
            local section_header=$2
            local in_section=0
            local section_content=""

            while IFS= read -r line; do
                if [[ $in_section -eq 1 ]]; then
                    if [[ "$line" =~ ^#\  ]]; then
                        break
                    fi
                    section_content+="$line"$'\n'
                fi
                if [[ "$line" == *"$section_header"* ]]; then
                    in_section=1
                    section_content+="$line"$'\n'
                fi
            done < "$source_file"

            echo "$section_content"
        }

        replace_in_file() {
            local target_file=$1
            local start_marker=$2
            local end_marker=$3
            local new_content=$4

            awk -v start="$start_marker" -v end="$end_marker" -v content="$new_content" '
            $0 ~ start {print; print content; in_block=1; next}
            in_block && $0 ~ end {in_block=0; print}
            !in_block {print}
            ' "$target_file" > tmpfile && mv tmpfile "$target_file"
        }

        changes_made=false

        for i in "${!sources[@]}"; do
            source_and_marker="${sources[$i]}"
            target="${targets[$i]}"
            start_marker="${start_markers[$i]}"
            end_marker="${end_markers[$i]}"

            IFS=" # " read -r source_file section_header <<< "$source_and_marker"

            new_content=$(extract_section "$source_file" "$section_header")

            current_content=$(awk -v start="$start_marker" -v end="$end_marker" '
            $0 ~ start {in_block=1; next}
            in_block && $0 ~ end {in_block=0}
            in_block {print}
            ' "$target")

            if [ "$new_content" != "$current_content" ]; then
                changes_made=true
                replace_in_file "$target" "$start_marker" "$end_marker" "$new_content"
                echo "Synced $section_header from $source_file to $target between $start_marker and $end_marker"
            else
                echo "No changes for $section_header in $source_file"
            fi
        done

        echo "::set-output name=changes_made::$changes_made"

    - name: Commit Changes
      if: steps.sync.outputs.changes_made == 'true'
      run: |
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"
        git add .
        git commit -m "Automated sync of README sections from multiple repositories"
        git push